__author__ = 'Will.Smith'
# -----------------------------------------------------------------------------
# Name:        FramUtil.py
# Purpose:     Python utilities for use in QML
#
# Author:      Will Smith <will.smith@noaa.gov>
#
# Created:     Jan 4, 2016
# License:     MIT
# ------------------------------------------------------------------------------

import os
import time
import unittest
import logging
import math
from fractions import Fraction
from enum import Enum
from contextlib import contextmanager
import subprocess

from PyQt5.QtCore import QObject, pyqtSlot, QVariant, QtMsgType


@contextmanager
def measureTime(title):
    """
    Test procedure, use 'with'
    http://stackoverflow.com/questions/2327719/timing-block-of-code-in-python-without-putting-it-in-a-function
    :param title: title of thing timed
    """
    t1 = time.clock()
    yield
    t2 = time.clock()
    logging.debug('%s: %0.2f seconds elapsed' % (title, t2 - t1))


class QtMessageType(Enum):
    """
    QtMsgType is supposed to be an enum, but doesn't seem to be implemented as an Enum

    QtDebugMsg	0	A message generated by the qDebug() function.
    QtInfoMsg	4	A message generated by the qInfo() function.
    QtWarningMsg	1	A message generated by the qWarning() function.
    QtCriticalMsg	2	A message generated by the qCritical() function.
    QtFatalMsg	3	A message generated by the qFatal() function.
    """
    QtDebugMsg = 0
    QtInfoMsg = 4
    QtWarningMsg = 1
    QtCriticalMsg = 2
    QtFatalMsg = 3


class FramUtil(QObject):
    def __init__(self):
        super().__init__()
        self._logger = logging.getLogger(__name__)

    @pyqtSlot(float, result="QVariant")
    def get_fraction(self, value):
        """
        Return fractional integer value list, given a float
        :param value: float input
        :return: QVariant list of numerator and denominator ints
        """
        # Convert tuple->list, PyQt doesn't like tuples
        try:
            if not value:  # Nulls, zeroes
                value = 1.0
            value = Fraction.from_float(value).limit_denominator(max_denominator=50)
            return QVariant([value.numerator, value.denominator])
        except ValueError as ve:
            self._logger.error(ve)
            return QVariant()

    @staticmethod
    def qt_msg_handler(msg_type, msg_log_context, msg_string):
        """
        Show qDebug() etc. messages as python logging
        :param msg_type: QtMsgType enum(debug, info, etc)
        :param msg_log_context: QMessageLogContext
        :param msg_string: Debug message
        """

        # Shorten lines with these
        file_text_to_hide = ['file:///C:/Python34/Lib/site-packages/PyQt5/']

        try:
            if msg_log_context is None:
                # Weird case, handle gracefully
                raise ValueError('msg_log_context is None')

            if msg_string is None:
                msg_string = ''

            if msg_log_context is not None and msg_log_context.file is None:
                console_msg = '[Qt]' + msg_string
            else:
                # remove redundant filename+line:
                msg_string = msg_string.replace(msg_log_context.file, '')
                for t in file_text_to_hide:  # short
                    if t in msg_log_context.file:
                        msg_log_context.file = msg_log_context.file.replace(t, '')
                console_msg = '[Qt]' + str(msg_log_context.file) + ':' + \
                              str(msg_log_context.line) + ' ' + \
                              str((msg_log_context.function + ': '
                                   if msg_log_context.function is not None else ' ')) + \
                              msg_string

            if msg_type == QtMessageType.QtDebugMsg.value:
                logging.debug(console_msg)
            elif msg_type == QtMessageType.QtInfoMsg.value:
                logging.info(console_msg)
            elif msg_type == QtMessageType.QtWarningMsg.value:
                logging.warning(console_msg)
            elif msg_type == QtMessageType.QtFatalMsg.value:
                logging.error(console_msg)
            elif msg_type == QtMessageType.QtCriticalMsg.value:
                logging.critical(console_msg)
            else:
                logging.info('[?]' + console_msg)

        except Exception as e:
            logging.debug('qt_msg_handler: ' + str(e))

    @staticmethod
    def ping_response(host, debug=False):
        """
        Windows-only
        :param host: host to ping
        :return True if host responds to a ping request
        """
        try:
            if debug:
                logging.info('Ping response DEBUG returning TRUE ALWAYS')
                return True

            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            return subprocess.check_output(['ping', '-n', '1', host],
                                           startupinfo=startupinfo,
                                           shell=False)

        except Exception as e:
            logging.info('ping_response exception, host: {0}, message: {1}'
                         .format(host, e))
            return str(e)

    @staticmethod
    def get_model_props(cls):
        """
        Gets a list of strings corresponding to a given DB Model (or any class)
        Based on  http://stackoverflow.com/questions/9058305/getting-attributes-of-a-class
        @param cls: DB Model or any class
        @return: list of strings (members)
        """
        skip_names = ('DoesNotExist')
        return [i for i in cls.__dict__.keys() if i[:1] != '_' and i not in skip_names]

    @staticmethod
    def convert_decimal_degs(dec_degs):
        """
        Converts from decimal degrees to degrees decimal minutes
        @return: degrees, decimal_minutes
        """

        deg_whole = math.floor(dec_degs) if dec_degs > 0 else math.ceil(dec_degs)
        dec_mins = (abs(dec_degs) - abs(deg_whole)) * 60.0
        return deg_whole, dec_mins


class TestFramUtil(unittest.TestCase):
    def setUp(self):
        logging.basicConfig(level=logging.DEBUG)
        self._framutil = FramUtil()

    def test_fraction(self):
        tests = [
            {'in': 0.25, 'out': [1, 4]},
            {'in': 1, 'out': [1, 1]},
            {'in': 1.0, 'out': [1, 1]},
            {'in': 0.33, 'out': [1, 3]},  # Test denominator simplification
            {'in': 0.125, 'out': [1, 8]},
            {'in': 0.0, 'out': [1, 1]},  # Test "bad" input (desired 0.0 -> return 1/1 )

        ]
        for t in tests:
            result = self._framutil.get_fraction(t['in']).value()  # Convert from QVariant to list
            self.assertEqual(result, t['out'], 'Bad fractional result')

    def test_msg_handler(self):
        # basic None testing, can't really test much
        FramUtil.qt_msg_handler(None, None, None)
        FramUtil.qt_msg_handler(QtMsgType(0), None, None)

    @unittest.skip("Failed ping returning message, not False")
    def test_ping_response(self):
        self.assertTrue(FramUtil.ping_response('127.0.0.1'))
        # Next test fails with
        # "AssertionError: "Command '['ping', '-n', '1', '0.0.0.0']' returned non-zero exit status 1." is not false"
        self.assertFalse(FramUtil.ping_response('0.0.0.0'))

    def test_decdegs(self):
        """
        Test GPS conversions. This found a bug in negative values!
        @return:
        """
        testvals = [[45.66, (45, 39.6)],
                    [-122.12345, (-122, 7.407)],
                    ]
        for val in testvals:
            res1, res2 = FramUtil.convert_decimal_degs(val[0])
            self.assertAlmostEqual(res1, val[1][0])
            self.assertAlmostEqual(res2, val[1][1])
